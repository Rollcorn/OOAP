/*****************************************************************************
 * И вот теперь, выяснив потенциальные подводные камни каждого из вариантов,
 * мы приходим к достаточно неплохому и теперь уже напрашивающемуся решению:
 * реализовать родительский класс, например, ParentList -- как частично
 * реализованный двунаправленный список без метода left(). В таком случае
 * LinkedList просто будет его прямым наследником, вообще никак родительскую
 * функциональность не расширяющим. И TwoWayList также унаследует все
 * возможности ParentList, а его непосредственная реализация будет
 * представлять всего лишь один новый метод left() (и, вероятно,
 * вспомогательный метод запроса статуса его работы). Это уже упоминавшийся
 * сильный подход частично реализованных классов (хотя в данном случае
 * родительский класс реализован полностью).
 */

abstract class ParentList<T> {
    // Статусы
    int HEAD_STATUS;
    int TAIL_STATUS;
    int RIGHT_STATUS;
    int PUT_RIGHT_STATUS;
    int PUT_LEFT_STATUS;
    int REMOVE_STATUS;
    int REPLACE_STATUS;
    int FIND_STATUS;
    int GET_STATUS;

    // Конструктор:
    // постусловие: создан новый пустой список
    public ParentList() {};

    /******************************************************************************************
     * Команды:
     */
    // предусловие: список не пустой
    // постусловие: курсор указывает на первый элемент списка
    public void head() { }

    // предусловие: список не пустой
    // постусловие: курсор указывает последний элемент списка
    public void tail() { }

    // предусловие: справа есть элемент
    // постусловие: курсор сдвинут на один узел вправо
    public void right() { }

    // предусловие: список не пуст;
// постусловие: перед текущим узлом новый узел с заданным значением
    public void putLeft(LinkedList.Node item) { }

    // предусловие: список не пуст;
    // постусловие: следом за текущим узлом новый узел с заданным значением
    public void putRight(LinkedList.Node item) { }

    // постусловие: в конце списка появляется новый элемент
    public void addTail(LinkedList.Node item) { }

    // предусловие: список не пуст;
    // постусловие: значение текущего узла заменено на новое
    public void replace(LinkedList.Node item) { }

    // предусловие: список не пуст;
    // постусловие: текущий узел удалён, курсор смещается к правому соседу, если он есть,
    //              в противном случае курсор смещается к левому соседу, если он есть
    public void remove() { }

    // постусловие: в списке отсутствуют элементы равные item
    public void removeAll(LinkedList.Node item) { }

    // постусловие: список пуст
    public void clear() { }

    // постусловие: курсор установлен на следующий узел
    //              с искомым значением, если такой узел найден
    public void find(LinkedList.Node item) { }

    /***************************************************************************************
     * Запросы:
     */
    public void get(LinkedList.Node item) { }

    public boolean isHead() { }

    public boolean isTail() { }

    public boolean isValue() { }

    public int size() { }

    /***************************************************************************************
     * Запросы статусов:
     */
    // успешно; список пуст
    public int getHeadStatus() {
        return HEAD_STATUS;
    }

    // успешно; список пуст
    public int getTailStatus() {
        return TAIL_STATUS;
    }

    // успешно; справа нет элемента
    public int getRightStatus() {
        return RIGHT_STATUS;
    }

    // успешно; список пуст
    public int getPutRightStatus() {
        return PUT_RIGHT_STATUS;
    }

    // успешно; список пуст
    public int getPutLeftStatus() {
        return PUT_LEFT_STATUS;
    }

    // успешно; список пуст
    public int getRemoveStatus() {
        return REMOVE_STATUS;
    }

    // успешно; список пуст
    public int getReplaceStatus() {
        return REPLACE_STATUS;
    }

    // элемент найден; элемент не найден; список пуст
    public int getFindStatus() {
        return FIND_STATUS;
    }

    // успешно; список пуст
    public int getGetStatus() {
        return GET_STATUS;
    }

}

class LinckedList<T> extends ParentList<T>{
    /******************************************************************************************
     * Конструктор:
     */
    // постусловие: пустой однонаправленный список
    public LinckedList() {
    }
}

public class TwoWayList<T> extends ParentList<T>{
    // Статусы
    int LEFT_STATUS;

    /******************************************************************************************
     * Конструктор:
     */
    // постусловие: пустой двунаправленный список
    public TwoWayList() {
    }

    /******************************************************************************************
     * Команды:
     */
    // предусловие: слева есть элемент
    // постусловие: курсор сдвинут на один узел влево
    public void left() { }

    /***************************************************************************************
     * Запросы статусов:
     */
    // успешно; справа нет элемента
    public int getLeftStatus() {
        return LEFT_STATUS;
    }
}
